#!/usr/bin/env ruby

require 'erb'
require 'pathname'
require 'fileutils'

require_relative 'run.rb'

REPO_ROOT = Pathname.new(File.join(File.dirname(__FILE__), '../')).realpath
PACKAGES_DIR = Pathname.new(File.join(REPO_ROOT, 'packages'))
GO_DIR = File.join(REPO_ROOT, 'go')
RUBY_DIR = File.join(REPO_ROOT, 'ruby', 'lib')
RUBY_VERSION_FILE = File.join('gitaly', 'version')

ENV['PATH'] = [
  File.join(ENV['GOPATH'], 'bin'),
  File.join(Dir.pwd, '_build/protoc/bin'),
  File.join(Dir.pwd, '_build/bin'),
  ENV['PATH'],
].join(':')

def main
  FileUtils.rm(Dir['go/**/*.pb.go'])
  FileUtils.rm(Dir[File.join(RUBY_DIR, '**/*_pb.rb')])

  packages = PACKAGES_DIR.children << REPO_ROOT
  packages.each { |directory| generate_package(directory) }

  write_ruby_requires
end

def write_ruby_requires
  requires = Dir.chdir(RUBY_DIR) { Dir['**/*_services_pb.rb'].sort }
  abort "No auto-generated Ruby service files found" if requires.empty?

  requires.unshift(File.join('gitaly', 'version'))

  gem_root = File.join(RUBY_DIR, 'gitaly.rb')
  gem_root_template = ERB.new <<EOT
# This file is generated by #{File.basename($0)}. Do not edit.
$:.unshift(File.expand_path('../gitaly', __FILE__))
<% requires.each do |f| %>
require '<%= f.sub(/\.rb$/, '') %>'
<% end %>
EOT
  open(gem_root, 'w') { |f| f.write(gem_root_template.result(binding)) }
end

def generate_package(dir)
  return unless File.directory?(dir)

  package_name = dir == REPO_ROOT ? '' : dir.basename
  Dir.chdir(dir) do
    files = Dir['*.proto'].sort

    go_package_dir = File.join(GO_DIR, package_name)
    ruby_lib_gitaly = File.join(RUBY_DIR, 'gitaly', package_name)

    # Generate Golang code
    FileUtils.mkdir_p(go_package_dir) unless Dir.exist?(go_package_dir)
    run!(%w[protoc -I .] + files + %W[--go_out=plugins=grpc:#{go_package_dir}])

    # Generate Ruby code
    FileUtils.mkdir_p(ruby_lib_gitaly) unless Dir.exist?(ruby_lib_gitaly)
    run!(%W[grpc_tools_ruby_protoc -I . --ruby_out=#{ruby_lib_gitaly} --grpc_out=#{ruby_lib_gitaly}] + files)
  end
end

main
