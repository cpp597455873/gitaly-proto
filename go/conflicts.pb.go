// Code generated by protoc-gen-go. DO NOT EDIT.
// source: conflicts.proto

package gitaly

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type ListConflictFilesRequest struct {
	Repository       *Repository `protobuf:"bytes,1,opt,name=repository" json:"repository,omitempty"`
	OurCommitOid     string      `protobuf:"bytes,2,opt,name=our_commit_oid,json=ourCommitOid" json:"our_commit_oid,omitempty"`
	TargetRepository *Repository `protobuf:"bytes,3,opt,name=target_repository,json=targetRepository" json:"target_repository,omitempty"`
	TheirCommitOid   string      `protobuf:"bytes,4,opt,name=their_commit_oid,json=theirCommitOid" json:"their_commit_oid,omitempty"`
}

func (m *ListConflictFilesRequest) Reset()                    { *m = ListConflictFilesRequest{} }
func (m *ListConflictFilesRequest) String() string            { return proto.CompactTextString(m) }
func (*ListConflictFilesRequest) ProtoMessage()               {}
func (*ListConflictFilesRequest) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0} }

func (m *ListConflictFilesRequest) GetRepository() *Repository {
	if m != nil {
		return m.Repository
	}
	return nil
}

func (m *ListConflictFilesRequest) GetOurCommitOid() string {
	if m != nil {
		return m.OurCommitOid
	}
	return ""
}

func (m *ListConflictFilesRequest) GetTargetRepository() *Repository {
	if m != nil {
		return m.TargetRepository
	}
	return nil
}

func (m *ListConflictFilesRequest) GetTheirCommitOid() string {
	if m != nil {
		return m.TheirCommitOid
	}
	return ""
}

type ConflictFileHeader struct {
	Repository *Repository `protobuf:"bytes,1,opt,name=repository" json:"repository,omitempty"`
	CommitOid  string      `protobuf:"bytes,2,opt,name=commit_oid,json=commitOid" json:"commit_oid,omitempty"`
	TheirPath  []byte      `protobuf:"bytes,3,opt,name=their_path,json=theirPath,proto3" json:"their_path,omitempty"`
	OurPath    []byte      `protobuf:"bytes,4,opt,name=our_path,json=ourPath,proto3" json:"our_path,omitempty"`
	OurMode    int32       `protobuf:"varint,5,opt,name=our_mode,json=ourMode" json:"our_mode,omitempty"`
}

func (m *ConflictFileHeader) Reset()                    { *m = ConflictFileHeader{} }
func (m *ConflictFileHeader) String() string            { return proto.CompactTextString(m) }
func (*ConflictFileHeader) ProtoMessage()               {}
func (*ConflictFileHeader) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{1} }

func (m *ConflictFileHeader) GetRepository() *Repository {
	if m != nil {
		return m.Repository
	}
	return nil
}

func (m *ConflictFileHeader) GetCommitOid() string {
	if m != nil {
		return m.CommitOid
	}
	return ""
}

func (m *ConflictFileHeader) GetTheirPath() []byte {
	if m != nil {
		return m.TheirPath
	}
	return nil
}

func (m *ConflictFileHeader) GetOurPath() []byte {
	if m != nil {
		return m.OurPath
	}
	return nil
}

func (m *ConflictFileHeader) GetOurMode() int32 {
	if m != nil {
		return m.OurMode
	}
	return 0
}

type ConflictFile struct {
	// Types that are valid to be assigned to ConflictFilePayload:
	//	*ConflictFile_Header
	//	*ConflictFile_Content
	ConflictFilePayload isConflictFile_ConflictFilePayload `protobuf_oneof:"conflict_file_payload"`
}

func (m *ConflictFile) Reset()                    { *m = ConflictFile{} }
func (m *ConflictFile) String() string            { return proto.CompactTextString(m) }
func (*ConflictFile) ProtoMessage()               {}
func (*ConflictFile) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{2} }

type isConflictFile_ConflictFilePayload interface {
	isConflictFile_ConflictFilePayload()
}

type ConflictFile_Header struct {
	Header *ConflictFileHeader `protobuf:"bytes,1,opt,name=header,oneof"`
}
type ConflictFile_Content struct {
	Content []byte `protobuf:"bytes,2,opt,name=content,proto3,oneof"`
}

func (*ConflictFile_Header) isConflictFile_ConflictFilePayload()  {}
func (*ConflictFile_Content) isConflictFile_ConflictFilePayload() {}

func (m *ConflictFile) GetConflictFilePayload() isConflictFile_ConflictFilePayload {
	if m != nil {
		return m.ConflictFilePayload
	}
	return nil
}

func (m *ConflictFile) GetHeader() *ConflictFileHeader {
	if x, ok := m.GetConflictFilePayload().(*ConflictFile_Header); ok {
		return x.Header
	}
	return nil
}

func (m *ConflictFile) GetContent() []byte {
	if x, ok := m.GetConflictFilePayload().(*ConflictFile_Content); ok {
		return x.Content
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ConflictFile) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ConflictFile_OneofMarshaler, _ConflictFile_OneofUnmarshaler, _ConflictFile_OneofSizer, []interface{}{
		(*ConflictFile_Header)(nil),
		(*ConflictFile_Content)(nil),
	}
}

func _ConflictFile_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ConflictFile)
	// conflict_file_payload
	switch x := m.ConflictFilePayload.(type) {
	case *ConflictFile_Header:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Header); err != nil {
			return err
		}
	case *ConflictFile_Content:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.Content)
	case nil:
	default:
		return fmt.Errorf("ConflictFile.ConflictFilePayload has unexpected type %T", x)
	}
	return nil
}

func _ConflictFile_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ConflictFile)
	switch tag {
	case 1: // conflict_file_payload.header
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ConflictFileHeader)
		err := b.DecodeMessage(msg)
		m.ConflictFilePayload = &ConflictFile_Header{msg}
		return true, err
	case 2: // conflict_file_payload.content
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.ConflictFilePayload = &ConflictFile_Content{x}
		return true, err
	default:
		return false, nil
	}
}

func _ConflictFile_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ConflictFile)
	// conflict_file_payload
	switch x := m.ConflictFilePayload.(type) {
	case *ConflictFile_Header:
		s := proto.Size(x.Header)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ConflictFile_Content:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Content)))
		n += len(x.Content)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ListConflictFilesResponse struct {
	Files []*ConflictFile `protobuf:"bytes,1,rep,name=files" json:"files,omitempty"`
}

func (m *ListConflictFilesResponse) Reset()                    { *m = ListConflictFilesResponse{} }
func (m *ListConflictFilesResponse) String() string            { return proto.CompactTextString(m) }
func (*ListConflictFilesResponse) ProtoMessage()               {}
func (*ListConflictFilesResponse) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{3} }

func (m *ListConflictFilesResponse) GetFiles() []*ConflictFile {
	if m != nil {
		return m.Files
	}
	return nil
}

type ResolveConflictsRequestHeader struct {
	Repository       *Repository `protobuf:"bytes,1,opt,name=repository" json:"repository,omitempty"`
	OurCommitOid     string      `protobuf:"bytes,2,opt,name=our_commit_oid,json=ourCommitOid" json:"our_commit_oid,omitempty"`
	TargetRepository *Repository `protobuf:"bytes,3,opt,name=target_repository,json=targetRepository" json:"target_repository,omitempty"`
	TheirCommitOid   string      `protobuf:"bytes,4,opt,name=their_commit_oid,json=theirCommitOid" json:"their_commit_oid,omitempty"`
	SourceBranch     []byte      `protobuf:"bytes,5,opt,name=source_branch,json=sourceBranch,proto3" json:"source_branch,omitempty"`
	TargetBranch     []byte      `protobuf:"bytes,6,opt,name=target_branch,json=targetBranch,proto3" json:"target_branch,omitempty"`
	CommitMessage    []byte      `protobuf:"bytes,7,opt,name=commit_message,json=commitMessage,proto3" json:"commit_message,omitempty"`
	User             *User       `protobuf:"bytes,8,opt,name=user" json:"user,omitempty"`
}

func (m *ResolveConflictsRequestHeader) Reset()                    { *m = ResolveConflictsRequestHeader{} }
func (m *ResolveConflictsRequestHeader) String() string            { return proto.CompactTextString(m) }
func (*ResolveConflictsRequestHeader) ProtoMessage()               {}
func (*ResolveConflictsRequestHeader) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{4} }

func (m *ResolveConflictsRequestHeader) GetRepository() *Repository {
	if m != nil {
		return m.Repository
	}
	return nil
}

func (m *ResolveConflictsRequestHeader) GetOurCommitOid() string {
	if m != nil {
		return m.OurCommitOid
	}
	return ""
}

func (m *ResolveConflictsRequestHeader) GetTargetRepository() *Repository {
	if m != nil {
		return m.TargetRepository
	}
	return nil
}

func (m *ResolveConflictsRequestHeader) GetTheirCommitOid() string {
	if m != nil {
		return m.TheirCommitOid
	}
	return ""
}

func (m *ResolveConflictsRequestHeader) GetSourceBranch() []byte {
	if m != nil {
		return m.SourceBranch
	}
	return nil
}

func (m *ResolveConflictsRequestHeader) GetTargetBranch() []byte {
	if m != nil {
		return m.TargetBranch
	}
	return nil
}

func (m *ResolveConflictsRequestHeader) GetCommitMessage() []byte {
	if m != nil {
		return m.CommitMessage
	}
	return nil
}

func (m *ResolveConflictsRequestHeader) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

type ResolveConflictsRequest struct {
	// Types that are valid to be assigned to ResolveConflictsRequestPayload:
	//	*ResolveConflictsRequest_Header
	//	*ResolveConflictsRequest_FilesJson
	ResolveConflictsRequestPayload isResolveConflictsRequest_ResolveConflictsRequestPayload `protobuf_oneof:"resolve_conflicts_request_payload"`
}

func (m *ResolveConflictsRequest) Reset()                    { *m = ResolveConflictsRequest{} }
func (m *ResolveConflictsRequest) String() string            { return proto.CompactTextString(m) }
func (*ResolveConflictsRequest) ProtoMessage()               {}
func (*ResolveConflictsRequest) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{5} }

type isResolveConflictsRequest_ResolveConflictsRequestPayload interface {
	isResolveConflictsRequest_ResolveConflictsRequestPayload()
}

type ResolveConflictsRequest_Header struct {
	Header *ResolveConflictsRequestHeader `protobuf:"bytes,1,opt,name=header,oneof"`
}
type ResolveConflictsRequest_FilesJson struct {
	FilesJson []byte `protobuf:"bytes,2,opt,name=files_json,json=filesJson,proto3,oneof"`
}

func (*ResolveConflictsRequest_Header) isResolveConflictsRequest_ResolveConflictsRequestPayload()    {}
func (*ResolveConflictsRequest_FilesJson) isResolveConflictsRequest_ResolveConflictsRequestPayload() {}

func (m *ResolveConflictsRequest) GetResolveConflictsRequestPayload() isResolveConflictsRequest_ResolveConflictsRequestPayload {
	if m != nil {
		return m.ResolveConflictsRequestPayload
	}
	return nil
}

func (m *ResolveConflictsRequest) GetHeader() *ResolveConflictsRequestHeader {
	if x, ok := m.GetResolveConflictsRequestPayload().(*ResolveConflictsRequest_Header); ok {
		return x.Header
	}
	return nil
}

func (m *ResolveConflictsRequest) GetFilesJson() []byte {
	if x, ok := m.GetResolveConflictsRequestPayload().(*ResolveConflictsRequest_FilesJson); ok {
		return x.FilesJson
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ResolveConflictsRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ResolveConflictsRequest_OneofMarshaler, _ResolveConflictsRequest_OneofUnmarshaler, _ResolveConflictsRequest_OneofSizer, []interface{}{
		(*ResolveConflictsRequest_Header)(nil),
		(*ResolveConflictsRequest_FilesJson)(nil),
	}
}

func _ResolveConflictsRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ResolveConflictsRequest)
	// resolve_conflicts_request_payload
	switch x := m.ResolveConflictsRequestPayload.(type) {
	case *ResolveConflictsRequest_Header:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Header); err != nil {
			return err
		}
	case *ResolveConflictsRequest_FilesJson:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.FilesJson)
	case nil:
	default:
		return fmt.Errorf("ResolveConflictsRequest.ResolveConflictsRequestPayload has unexpected type %T", x)
	}
	return nil
}

func _ResolveConflictsRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ResolveConflictsRequest)
	switch tag {
	case 1: // resolve_conflicts_request_payload.header
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ResolveConflictsRequestHeader)
		err := b.DecodeMessage(msg)
		m.ResolveConflictsRequestPayload = &ResolveConflictsRequest_Header{msg}
		return true, err
	case 2: // resolve_conflicts_request_payload.files_json
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.ResolveConflictsRequestPayload = &ResolveConflictsRequest_FilesJson{x}
		return true, err
	default:
		return false, nil
	}
}

func _ResolveConflictsRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ResolveConflictsRequest)
	// resolve_conflicts_request_payload
	switch x := m.ResolveConflictsRequestPayload.(type) {
	case *ResolveConflictsRequest_Header:
		s := proto.Size(x.Header)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ResolveConflictsRequest_FilesJson:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.FilesJson)))
		n += len(x.FilesJson)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ResolveConflictsResponse struct {
	ResolutionError string `protobuf:"bytes,1,opt,name=resolution_error,json=resolutionError" json:"resolution_error,omitempty"`
}

func (m *ResolveConflictsResponse) Reset()                    { *m = ResolveConflictsResponse{} }
func (m *ResolveConflictsResponse) String() string            { return proto.CompactTextString(m) }
func (*ResolveConflictsResponse) ProtoMessage()               {}
func (*ResolveConflictsResponse) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{6} }

func (m *ResolveConflictsResponse) GetResolutionError() string {
	if m != nil {
		return m.ResolutionError
	}
	return ""
}

func init() {
	proto.RegisterType((*ListConflictFilesRequest)(nil), "gitaly.ListConflictFilesRequest")
	proto.RegisterType((*ConflictFileHeader)(nil), "gitaly.ConflictFileHeader")
	proto.RegisterType((*ConflictFile)(nil), "gitaly.ConflictFile")
	proto.RegisterType((*ListConflictFilesResponse)(nil), "gitaly.ListConflictFilesResponse")
	proto.RegisterType((*ResolveConflictsRequestHeader)(nil), "gitaly.ResolveConflictsRequestHeader")
	proto.RegisterType((*ResolveConflictsRequest)(nil), "gitaly.ResolveConflictsRequest")
	proto.RegisterType((*ResolveConflictsResponse)(nil), "gitaly.ResolveConflictsResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ConflictsService service

type ConflictsServiceClient interface {
	ListConflictFiles(ctx context.Context, in *ListConflictFilesRequest, opts ...grpc.CallOption) (ConflictsService_ListConflictFilesClient, error)
	ResolveConflicts(ctx context.Context, opts ...grpc.CallOption) (ConflictsService_ResolveConflictsClient, error)
}

type conflictsServiceClient struct {
	cc *grpc.ClientConn
}

func NewConflictsServiceClient(cc *grpc.ClientConn) ConflictsServiceClient {
	return &conflictsServiceClient{cc}
}

func (c *conflictsServiceClient) ListConflictFiles(ctx context.Context, in *ListConflictFilesRequest, opts ...grpc.CallOption) (ConflictsService_ListConflictFilesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ConflictsService_serviceDesc.Streams[0], c.cc, "/gitaly.ConflictsService/ListConflictFiles", opts...)
	if err != nil {
		return nil, err
	}
	x := &conflictsServiceListConflictFilesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ConflictsService_ListConflictFilesClient interface {
	Recv() (*ListConflictFilesResponse, error)
	grpc.ClientStream
}

type conflictsServiceListConflictFilesClient struct {
	grpc.ClientStream
}

func (x *conflictsServiceListConflictFilesClient) Recv() (*ListConflictFilesResponse, error) {
	m := new(ListConflictFilesResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *conflictsServiceClient) ResolveConflicts(ctx context.Context, opts ...grpc.CallOption) (ConflictsService_ResolveConflictsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ConflictsService_serviceDesc.Streams[1], c.cc, "/gitaly.ConflictsService/ResolveConflicts", opts...)
	if err != nil {
		return nil, err
	}
	x := &conflictsServiceResolveConflictsClient{stream}
	return x, nil
}

type ConflictsService_ResolveConflictsClient interface {
	Send(*ResolveConflictsRequest) error
	CloseAndRecv() (*ResolveConflictsResponse, error)
	grpc.ClientStream
}

type conflictsServiceResolveConflictsClient struct {
	grpc.ClientStream
}

func (x *conflictsServiceResolveConflictsClient) Send(m *ResolveConflictsRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *conflictsServiceResolveConflictsClient) CloseAndRecv() (*ResolveConflictsResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(ResolveConflictsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for ConflictsService service

type ConflictsServiceServer interface {
	ListConflictFiles(*ListConflictFilesRequest, ConflictsService_ListConflictFilesServer) error
	ResolveConflicts(ConflictsService_ResolveConflictsServer) error
}

func RegisterConflictsServiceServer(s *grpc.Server, srv ConflictsServiceServer) {
	s.RegisterService(&_ConflictsService_serviceDesc, srv)
}

func _ConflictsService_ListConflictFiles_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListConflictFilesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ConflictsServiceServer).ListConflictFiles(m, &conflictsServiceListConflictFilesServer{stream})
}

type ConflictsService_ListConflictFilesServer interface {
	Send(*ListConflictFilesResponse) error
	grpc.ServerStream
}

type conflictsServiceListConflictFilesServer struct {
	grpc.ServerStream
}

func (x *conflictsServiceListConflictFilesServer) Send(m *ListConflictFilesResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _ConflictsService_ResolveConflicts_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ConflictsServiceServer).ResolveConflicts(&conflictsServiceResolveConflictsServer{stream})
}

type ConflictsService_ResolveConflictsServer interface {
	SendAndClose(*ResolveConflictsResponse) error
	Recv() (*ResolveConflictsRequest, error)
	grpc.ServerStream
}

type conflictsServiceResolveConflictsServer struct {
	grpc.ServerStream
}

func (x *conflictsServiceResolveConflictsServer) SendAndClose(m *ResolveConflictsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *conflictsServiceResolveConflictsServer) Recv() (*ResolveConflictsRequest, error) {
	m := new(ResolveConflictsRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _ConflictsService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "gitaly.ConflictsService",
	HandlerType: (*ConflictsServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListConflictFiles",
			Handler:       _ConflictsService_ListConflictFiles_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ResolveConflicts",
			Handler:       _ConflictsService_ResolveConflicts_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "conflicts.proto",
}

func init() { proto.RegisterFile("conflicts.proto", fileDescriptor2) }

var fileDescriptor2 = []byte{
	// 573 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x54, 0xdd, 0x6a, 0x13, 0x41,
	0x18, 0xed, 0xb6, 0xf9, 0x69, 0xbe, 0x6e, 0xd3, 0x74, 0x50, 0xba, 0x0d, 0x84, 0x6e, 0xb7, 0x16,
	0x56, 0x2f, 0x82, 0x44, 0xef, 0x0b, 0x29, 0xd5, 0x20, 0x16, 0x65, 0xc4, 0x0b, 0x41, 0x58, 0xb6,
	0xbb, 0x5f, 0xb3, 0x23, 0x9b, 0x9d, 0x38, 0x33, 0x5b, 0xc8, 0xdb, 0xf8, 0x20, 0xbe, 0x81, 0x0f,
	0xe1, 0x63, 0x78, 0x2b, 0x99, 0xd9, 0xdd, 0xa4, 0x4d, 0x53, 0x41, 0x6f, 0xbc, 0x3d, 0xdf, 0xe1,
	0x3b, 0xe7, 0xcc, 0x77, 0x18, 0xd8, 0x8b, 0x78, 0x76, 0x9d, 0xb2, 0x48, 0xc9, 0xfe, 0x54, 0x70,
	0xc5, 0x49, 0x63, 0xcc, 0x54, 0x98, 0xce, 0xba, 0xb6, 0x4c, 0x42, 0x81, 0xb1, 0x41, 0xbd, 0x9f,
	0x16, 0x38, 0x6f, 0x99, 0x54, 0xe7, 0x05, 0xfb, 0x15, 0x4b, 0x51, 0x52, 0xfc, 0x9a, 0xa3, 0x54,
	0x64, 0x00, 0x20, 0x70, 0xca, 0x25, 0x53, 0x5c, 0xcc, 0x1c, 0xcb, 0xb5, 0xfc, 0x9d, 0x01, 0xe9,
	0x9b, 0x3d, 0x7d, 0x5a, 0x4d, 0xe8, 0x12, 0x8b, 0x3c, 0x81, 0x36, 0xcf, 0x45, 0x10, 0xf1, 0xc9,
	0x84, 0xa9, 0x80, 0xb3, 0xd8, 0xd9, 0x74, 0x2d, 0xbf, 0x45, 0x6d, 0x9e, 0x8b, 0x73, 0x0d, 0xbe,
	0x63, 0x31, 0x39, 0x83, 0x7d, 0x15, 0x8a, 0x31, 0xaa, 0x60, 0x49, 0x60, 0x6b, 0xad, 0x40, 0xc7,
	0x90, 0x17, 0x08, 0xf1, 0xa1, 0xa3, 0x12, 0x64, 0xb7, 0x84, 0x6a, 0x5a, 0xa8, 0xad, 0xf1, 0x4a,
	0xca, 0xfb, 0x6e, 0x01, 0x59, 0x4e, 0x37, 0xc2, 0x30, 0x46, 0xf1, 0x57, 0xd9, 0x7a, 0x00, 0x2b,
	0xb9, 0x5a, 0x51, 0x15, 0xaa, 0x07, 0x60, 0x3c, 0x4d, 0x43, 0x95, 0xe8, 0x34, 0x36, 0x6d, 0x69,
	0xe4, 0x7d, 0xa8, 0x12, 0x72, 0x08, 0xdb, 0xf3, 0x97, 0xd1, 0xc3, 0x9a, 0x1e, 0x36, 0x79, 0x7e,
	0x6b, 0x34, 0xe1, 0x31, 0x3a, 0x75, 0xd7, 0xf2, 0xeb, 0x7a, 0x74, 0xc9, 0x63, 0xf4, 0x66, 0x60,
	0x2f, 0xbb, 0x27, 0x2f, 0xa1, 0x91, 0xe8, 0x04, 0x85, 0xe7, 0x6e, 0xe9, 0x79, 0x35, 0xe3, 0x68,
	0x83, 0x16, 0x5c, 0xd2, 0x85, 0x66, 0xc4, 0x33, 0x85, 0x99, 0xd2, 0xb6, 0xed, 0xd1, 0x06, 0x2d,
	0x81, 0xe1, 0x01, 0x3c, 0x2e, 0xbb, 0x12, 0x5c, 0xb3, 0x14, 0x83, 0x69, 0x38, 0x4b, 0x79, 0x18,
	0x7b, 0xaf, 0xe1, 0xf0, 0x9e, 0x6a, 0xc8, 0x29, 0xcf, 0x24, 0x92, 0x67, 0x50, 0x9f, 0x93, 0xa5,
	0x63, 0xb9, 0x5b, 0xfe, 0xce, 0xe0, 0xd1, 0x7d, 0x36, 0xa8, 0xa1, 0x78, 0xbf, 0x36, 0xa1, 0x47,
	0x51, 0xf2, 0xf4, 0x06, 0xcb, 0x71, 0xd9, 0xb1, 0x7f, 0xb8, 0xc6, 0xff, 0xd6, 0x34, 0x72, 0x02,
	0xbb, 0x92, 0xe7, 0x22, 0xc2, 0xe0, 0x4a, 0x84, 0x59, 0x94, 0xe8, 0x53, 0xda, 0xd4, 0x36, 0xe0,
	0x50, 0x63, 0x73, 0x52, 0xe1, 0xa7, 0x20, 0x35, 0x0c, 0xc9, 0x80, 0x05, 0xe9, 0x14, 0xda, 0x85,
	0xda, 0x04, 0xa5, 0x0c, 0xc7, 0xe8, 0x34, 0x35, 0x6b, 0xd7, 0xa0, 0x97, 0x06, 0x24, 0x2e, 0xd4,
	0x72, 0x89, 0xc2, 0xd9, 0xd6, 0x71, 0xec, 0x32, 0xce, 0x47, 0x89, 0x82, 0xea, 0x89, 0xf7, 0xcd,
	0x82, 0x83, 0x35, 0x2f, 0x4f, 0xce, 0xee, 0x34, 0xe9, 0x74, 0xf1, 0x1c, 0x0f, 0x9c, 0x6a, 0xa9,
	0x54, 0x47, 0x00, 0xfa, 0xbe, 0xc1, 0x17, 0xc9, 0xb3, 0xaa, 0x57, 0x2d, 0x8d, 0xbd, 0x91, 0x3c,
	0x1b, 0x9e, 0xc0, 0xb1, 0x30, 0xbb, 0x82, 0xea, 0x37, 0x0a, 0x84, 0xd9, 0x56, 0xb5, 0xec, 0x02,
	0x9c, 0x55, 0xc1, 0xa2, 0x64, 0x4f, 0xa1, 0xa3, 0x17, 0xe4, 0x8a, 0xf1, 0x2c, 0x40, 0x21, 0xb8,
	0x31, 0xdb, 0xa2, 0x7b, 0x0b, 0xfc, 0x62, 0x0e, 0x0f, 0x7e, 0x58, 0xd0, 0xa9, 0x16, 0x7c, 0x40,
	0x71, 0xc3, 0x22, 0x24, 0x9f, 0x61, 0x7f, 0xa5, 0xc1, 0xc4, 0x2d, 0x73, 0xae, 0xfb, 0xf7, 0xba,
	0xc7, 0x0f, 0x30, 0x8c, 0x33, 0x6f, 0xe3, 0xb9, 0x45, 0x3e, 0x41, 0xe7, 0xae, 0x73, 0x72, 0xf4,
	0x87, 0x47, 0xec, 0xba, 0xeb, 0x09, 0xe5, 0x6a, 0xdf, 0xba, 0x6a, 0xe8, 0xdf, 0xf9, 0xc5, 0xef,
	0x00, 0x00, 0x00, 0xff, 0xff, 0xc0, 0x74, 0x28, 0x6e, 0xc6, 0x05, 0x00, 0x00,
}
