// Code generated by protoc-gen-go. DO NOT EDIT.
// source: conflicts.proto

package gitaly

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type ListConflictFilesRequest struct {
	Repository       *Repository `protobuf:"bytes,1,opt,name=repository" json:"repository,omitempty"`
	OurCommitOid     string      `protobuf:"bytes,2,opt,name=our_commit_oid,json=ourCommitOid" json:"our_commit_oid,omitempty"`
	TargetRepository *Repository `protobuf:"bytes,3,opt,name=target_repository,json=targetRepository" json:"target_repository,omitempty"`
	TheirCommitOid   string      `protobuf:"bytes,4,opt,name=their_commit_oid,json=theirCommitOid" json:"their_commit_oid,omitempty"`
}

func (m *ListConflictFilesRequest) Reset()                    { *m = ListConflictFilesRequest{} }
func (m *ListConflictFilesRequest) String() string            { return proto.CompactTextString(m) }
func (*ListConflictFilesRequest) ProtoMessage()               {}
func (*ListConflictFilesRequest) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0} }

func (m *ListConflictFilesRequest) GetRepository() *Repository {
	if m != nil {
		return m.Repository
	}
	return nil
}

func (m *ListConflictFilesRequest) GetOurCommitOid() string {
	if m != nil {
		return m.OurCommitOid
	}
	return ""
}

func (m *ListConflictFilesRequest) GetTargetRepository() *Repository {
	if m != nil {
		return m.TargetRepository
	}
	return nil
}

func (m *ListConflictFilesRequest) GetTheirCommitOid() string {
	if m != nil {
		return m.TheirCommitOid
	}
	return ""
}

type ConflictFileHeader struct {
	Repository *Repository `protobuf:"bytes,1,opt,name=repository" json:"repository,omitempty"`
	CommitOid  string      `protobuf:"bytes,2,opt,name=commit_oid,json=commitOid" json:"commit_oid,omitempty"`
	TheirPath  []byte      `protobuf:"bytes,3,opt,name=their_path,json=theirPath,proto3" json:"their_path,omitempty"`
	OurPath    []byte      `protobuf:"bytes,4,opt,name=our_path,json=ourPath,proto3" json:"our_path,omitempty"`
	OurMode    int32       `protobuf:"varint,5,opt,name=our_mode,json=ourMode" json:"our_mode,omitempty"`
}

func (m *ConflictFileHeader) Reset()                    { *m = ConflictFileHeader{} }
func (m *ConflictFileHeader) String() string            { return proto.CompactTextString(m) }
func (*ConflictFileHeader) ProtoMessage()               {}
func (*ConflictFileHeader) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{1} }

func (m *ConflictFileHeader) GetRepository() *Repository {
	if m != nil {
		return m.Repository
	}
	return nil
}

func (m *ConflictFileHeader) GetCommitOid() string {
	if m != nil {
		return m.CommitOid
	}
	return ""
}

func (m *ConflictFileHeader) GetTheirPath() []byte {
	if m != nil {
		return m.TheirPath
	}
	return nil
}

func (m *ConflictFileHeader) GetOurPath() []byte {
	if m != nil {
		return m.OurPath
	}
	return nil
}

func (m *ConflictFileHeader) GetOurMode() int32 {
	if m != nil {
		return m.OurMode
	}
	return 0
}

type ConflictFile struct {
	// Types that are valid to be assigned to ConflictFilePayload:
	//	*ConflictFile_Header
	//	*ConflictFile_Content
	ConflictFilePayload isConflictFile_ConflictFilePayload `protobuf_oneof:"conflict_file_payload"`
}

func (m *ConflictFile) Reset()                    { *m = ConflictFile{} }
func (m *ConflictFile) String() string            { return proto.CompactTextString(m) }
func (*ConflictFile) ProtoMessage()               {}
func (*ConflictFile) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{2} }

type isConflictFile_ConflictFilePayload interface {
	isConflictFile_ConflictFilePayload()
}

type ConflictFile_Header struct {
	Header *ConflictFileHeader `protobuf:"bytes,1,opt,name=header,oneof"`
}
type ConflictFile_Content struct {
	Content []byte `protobuf:"bytes,2,opt,name=content,proto3,oneof"`
}

func (*ConflictFile_Header) isConflictFile_ConflictFilePayload()  {}
func (*ConflictFile_Content) isConflictFile_ConflictFilePayload() {}

func (m *ConflictFile) GetConflictFilePayload() isConflictFile_ConflictFilePayload {
	if m != nil {
		return m.ConflictFilePayload
	}
	return nil
}

func (m *ConflictFile) GetHeader() *ConflictFileHeader {
	if x, ok := m.GetConflictFilePayload().(*ConflictFile_Header); ok {
		return x.Header
	}
	return nil
}

func (m *ConflictFile) GetContent() []byte {
	if x, ok := m.GetConflictFilePayload().(*ConflictFile_Content); ok {
		return x.Content
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ConflictFile) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ConflictFile_OneofMarshaler, _ConflictFile_OneofUnmarshaler, _ConflictFile_OneofSizer, []interface{}{
		(*ConflictFile_Header)(nil),
		(*ConflictFile_Content)(nil),
	}
}

func _ConflictFile_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ConflictFile)
	// conflict_file_payload
	switch x := m.ConflictFilePayload.(type) {
	case *ConflictFile_Header:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Header); err != nil {
			return err
		}
	case *ConflictFile_Content:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.Content)
	case nil:
	default:
		return fmt.Errorf("ConflictFile.ConflictFilePayload has unexpected type %T", x)
	}
	return nil
}

func _ConflictFile_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ConflictFile)
	switch tag {
	case 1: // conflict_file_payload.header
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ConflictFileHeader)
		err := b.DecodeMessage(msg)
		m.ConflictFilePayload = &ConflictFile_Header{msg}
		return true, err
	case 2: // conflict_file_payload.content
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.ConflictFilePayload = &ConflictFile_Content{x}
		return true, err
	default:
		return false, nil
	}
}

func _ConflictFile_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ConflictFile)
	// conflict_file_payload
	switch x := m.ConflictFilePayload.(type) {
	case *ConflictFile_Header:
		s := proto.Size(x.Header)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ConflictFile_Content:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Content)))
		n += len(x.Content)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ListConflictFilesResponse struct {
	Files []*ConflictFile `protobuf:"bytes,1,rep,name=files" json:"files,omitempty"`
}

func (m *ListConflictFilesResponse) Reset()                    { *m = ListConflictFilesResponse{} }
func (m *ListConflictFilesResponse) String() string            { return proto.CompactTextString(m) }
func (*ListConflictFilesResponse) ProtoMessage()               {}
func (*ListConflictFilesResponse) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{3} }

func (m *ListConflictFilesResponse) GetFiles() []*ConflictFile {
	if m != nil {
		return m.Files
	}
	return nil
}

func init() {
	proto.RegisterType((*ListConflictFilesRequest)(nil), "gitaly.ListConflictFilesRequest")
	proto.RegisterType((*ConflictFileHeader)(nil), "gitaly.ConflictFileHeader")
	proto.RegisterType((*ConflictFile)(nil), "gitaly.ConflictFile")
	proto.RegisterType((*ListConflictFilesResponse)(nil), "gitaly.ListConflictFilesResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ConflictsService service

type ConflictsServiceClient interface {
	ListConflictFiles(ctx context.Context, in *ListConflictFilesRequest, opts ...grpc.CallOption) (ConflictsService_ListConflictFilesClient, error)
}

type conflictsServiceClient struct {
	cc *grpc.ClientConn
}

func NewConflictsServiceClient(cc *grpc.ClientConn) ConflictsServiceClient {
	return &conflictsServiceClient{cc}
}

func (c *conflictsServiceClient) ListConflictFiles(ctx context.Context, in *ListConflictFilesRequest, opts ...grpc.CallOption) (ConflictsService_ListConflictFilesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ConflictsService_serviceDesc.Streams[0], c.cc, "/gitaly.ConflictsService/ListConflictFiles", opts...)
	if err != nil {
		return nil, err
	}
	x := &conflictsServiceListConflictFilesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ConflictsService_ListConflictFilesClient interface {
	Recv() (*ListConflictFilesResponse, error)
	grpc.ClientStream
}

type conflictsServiceListConflictFilesClient struct {
	grpc.ClientStream
}

func (x *conflictsServiceListConflictFilesClient) Recv() (*ListConflictFilesResponse, error) {
	m := new(ListConflictFilesResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for ConflictsService service

type ConflictsServiceServer interface {
	ListConflictFiles(*ListConflictFilesRequest, ConflictsService_ListConflictFilesServer) error
}

func RegisterConflictsServiceServer(s *grpc.Server, srv ConflictsServiceServer) {
	s.RegisterService(&_ConflictsService_serviceDesc, srv)
}

func _ConflictsService_ListConflictFiles_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListConflictFilesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ConflictsServiceServer).ListConflictFiles(m, &conflictsServiceListConflictFilesServer{stream})
}

type ConflictsService_ListConflictFilesServer interface {
	Send(*ListConflictFilesResponse) error
	grpc.ServerStream
}

type conflictsServiceListConflictFilesServer struct {
	grpc.ServerStream
}

func (x *conflictsServiceListConflictFilesServer) Send(m *ListConflictFilesResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _ConflictsService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "gitaly.ConflictsService",
	HandlerType: (*ConflictsServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListConflictFiles",
			Handler:       _ConflictsService_ListConflictFiles_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "conflicts.proto",
}

func init() { proto.RegisterFile("conflicts.proto", fileDescriptor2) }

var fileDescriptor2 = []byte{
	// 379 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x52, 0x4f, 0xeb, 0xd3, 0x40,
	0x14, 0xec, 0xda, 0x7f, 0xf6, 0x35, 0xd4, 0x76, 0x51, 0x4c, 0x03, 0x85, 0x18, 0x3c, 0x04, 0x0f,
	0x45, 0xa2, 0x77, 0xc1, 0x82, 0xf6, 0xa0, 0x28, 0xeb, 0x55, 0x08, 0x6b, 0xf2, 0xda, 0x2c, 0xa4,
	0xd9, 0xb8, 0xbb, 0x11, 0xf2, 0xdd, 0xfc, 0x2e, 0x7e, 0x15, 0xe9, 0xa6, 0xa9, 0x29, 0x6d, 0x3d,
	0xfc, 0xae, 0x33, 0xc3, 0x9b, 0x99, 0xc7, 0xc0, 0x93, 0x44, 0x16, 0xbb, 0x5c, 0x24, 0x46, 0xaf,
	0x4b, 0x25, 0x8d, 0xa4, 0xa3, 0xbd, 0x30, 0x3c, 0xaf, 0x3d, 0x47, 0x67, 0x5c, 0x61, 0xda, 0xa0,
	0xc1, 0x1f, 0x02, 0xee, 0x27, 0xa1, 0xcd, 0xe6, 0xa4, 0xfe, 0x20, 0x72, 0xd4, 0x0c, 0x7f, 0x56,
	0xa8, 0x0d, 0x8d, 0x00, 0x14, 0x96, 0x52, 0x0b, 0x23, 0x55, 0xed, 0x12, 0x9f, 0x84, 0xd3, 0x88,
	0xae, 0x9b, 0x3b, 0x6b, 0x76, 0x66, 0x58, 0x47, 0x45, 0x5f, 0xc2, 0x4c, 0x56, 0x2a, 0x4e, 0xe4,
	0xe1, 0x20, 0x4c, 0x2c, 0x45, 0xea, 0x3e, 0xf2, 0x49, 0x38, 0x61, 0x8e, 0xac, 0xd4, 0xc6, 0x82,
	0x5f, 0x44, 0x4a, 0xdf, 0xc1, 0xc2, 0x70, 0xb5, 0x47, 0x13, 0x77, 0x0c, 0xfa, 0x77, 0x0d, 0xe6,
	0x8d, 0xf8, 0x1f, 0x42, 0x43, 0x98, 0x9b, 0x0c, 0xc5, 0x85, 0xd1, 0xc0, 0x1a, 0xcd, 0x2c, 0x7e,
	0xb6, 0x0a, 0x7e, 0x13, 0xa0, 0xdd, 0x76, 0x5b, 0xe4, 0x29, 0xaa, 0x07, 0x75, 0x5b, 0x01, 0x5c,
	0xf5, 0x9a, 0x24, 0xe7, 0x52, 0x2b, 0x80, 0x26, 0x53, 0xc9, 0x4d, 0x66, 0xdb, 0x38, 0x6c, 0x62,
	0x91, 0xaf, 0xdc, 0x64, 0x74, 0x09, 0x8f, 0x8f, 0x9f, 0xb1, 0xe4, 0xc0, 0x92, 0x63, 0x59, 0x5d,
	0x50, 0x07, 0x99, 0xa2, 0x3b, 0xf4, 0x49, 0x38, 0xb4, 0xd4, 0x67, 0x99, 0x62, 0x50, 0x83, 0xd3,
	0x4d, 0x4f, 0xdf, 0xc2, 0x28, 0xb3, 0x0d, 0x4e, 0x99, 0xbd, 0x36, 0xf3, 0x75, 0xc7, 0x6d, 0x8f,
	0x9d, 0xb4, 0xd4, 0x83, 0x71, 0x22, 0x0b, 0x83, 0x85, 0xb1, 0xb1, 0x9d, 0x6d, 0x8f, 0xb5, 0xc0,
	0xfb, 0xe7, 0xf0, 0xac, 0xdd, 0x4a, 0xbc, 0x13, 0x39, 0xc6, 0x25, 0xaf, 0x73, 0xc9, 0xd3, 0xe0,
	0x23, 0x2c, 0x6f, 0x4c, 0x43, 0x97, 0xb2, 0xd0, 0x48, 0x5f, 0xc1, 0xf0, 0x28, 0xd6, 0x2e, 0xf1,
	0xfb, 0xe1, 0x34, 0x7a, 0x7a, 0x2b, 0x06, 0x6b, 0x24, 0x51, 0x09, 0xf3, 0x16, 0xd6, 0xdf, 0x50,
	0xfd, 0x12, 0x09, 0xd2, 0xef, 0xb0, 0xb8, 0x3a, 0x4e, 0xfd, 0xf6, 0xca, 0xbd, 0x49, 0x7a, 0x2f,
	0xfe, 0xa3, 0x68, 0x92, 0x05, 0xbd, 0xd7, 0xe4, 0xc7, 0xc8, 0xae, 0xfb, 0xcd, 0xdf, 0x00, 0x00,
	0x00, 0xff, 0xff, 0xee, 0x29, 0xae, 0xb8, 0x06, 0x03, 0x00, 0x00,
}
